import crypto from 'node:crypto'
import fs from 'node:fs'
import path from 'node:path'
import { type Client, sql } from 'pg-nano'
import { group, sift } from 'radashi'
import type { Env } from './env'
import { log } from './log'
import { parseIdentifier } from './parseIdentifier'
import { dedent } from './util/dedent'

type SQLObject = {
  id: string
  type: string
  stmtIndex: number
}

type SQLFunc = SQLObject & { signature: string }

export async function prepareForMigration(filePaths: string[], env: Env) {
  const client = await env.client

  fs.rmSync(env.schemaDir, { recursive: true, force: true })
  fs.mkdirSync(env.schemaDir, { recursive: true })

  const { pre: prePlanFiles, rest: schemaFiles = [] } = group(
    filePaths,
    file => {
      const name = path.basename(file)
      return name[0] === '!' ? 'pre' : 'rest'
    },
  )

  let prePlanDDL = dedent`
    SET check_function_bodies = off;\n\n
  `

  if (prePlanFiles) {
    prePlanDDL +=
      prePlanFiles.map(file => fs.readFileSync(file, 'utf8')).join('\n\n') +
      '\n\n'
  }

  const fixedFuncs: SQLFunc[] = []
  const declaredTypes: SQLObject[] = []

  const schemaObjects: SQLObject[] = []
  const parsedSchemaFiles = schemaFiles.map(file => {
    const stmts = splitStatements(fs.readFileSync(file, 'utf8'))
    const objects = stmts.map((stmt,stmtIndex) => {
      const match = stmt.match(
        /(?:^|\n)CREATE\s+(?:OR\s+REPLACE\s+)?(\w+)\s+(?:IF\s+NOT\s+EXISTS\s+)?(.+?)\s+(?:AS\b|ON\b|\()/i,
      )
      if (match) {
        let [, type, id] = match
        type = type.toLowerCase()

        return {
          id,
          type,
          stmtIndex
        }
      }
      return null
    })
    return { file, stmts, objects }
  })

  for (const { file, stmts, objects } of parsedSchemaFiles) {
    const outFile = path.join(
      env.schemaDir,
      path.basename(file, path.extname(file)) +
        '.' +
        md5Hash(file).slice(0, 8) +
        '.sql',
    )

    const unhandledStmts: string[] = []
    for (let i = 0; i < stmts.length; i++) {
      const stmt = stmts[i]
      const object = objects[i]
      if (!object) {
        unhandledStmts.push(stmt)
        continue
      }
      if (object.type === 'function') {
        const matchedSetOf =
          /\bRETURNS\s+SETOF\s+(.+?)\s+AS\b/i.exec(
            stmt,
          )

        // When a function uses SETOF with a table identifier, that table may
        // not exist before pg-schema-diff creates the function. This issue is
        // tracked by https://github.com/stripe/pg-schema-diff/issues/129.
        //
        // Therefore, we need to ensure the table exists before applying the
        // migration plan generated by pg-schema-diff.
        if (matchedSetOf) {
          const rowType = schemaObjects.find(
            obj => obj.type === 'table' && compareIdentifiers(obj.id, matchedSetOf[1]),
          )
          if (rowType) {
            const tableId = parseIdentifier(rowType.id)
            const tableSchema = tableId.schema
              ? unquote(tableId.schema)
              : 'public'

            const tableExists = await client.scalar<boolean>(sql`
              SELECT EXISTS (
                SELECT 1
                FROM pg_tables
                WHERE schemaname = ${sql.val(tableSchema)}
                  AND tablename = ${sql.val(tableId.name)}
              );
            `)

            // Ensure the table exists before the function is created/replaced.
            // If the table already exists, we don't need to do anything, since
            // pg-schema-diff will handle any changes to the table definition.
            if (!tableExists) {
              await client.query(sql`
                CREATE TABLE ${tableId.toSQL()} (tmp int);
                ALTER TABLE ${tableId.toSQL()} DROP COLUMN tmp;
              `)
            }
          }
        }
      } else {
        // Non-enum types are not supported by pg-schema-diff, so we need to
        // diff them manually.
        const typeMatch = /\bCREATE\s+TYPE\s+(.+?)\s+AS(\s+ENUM)?\b/i.exec(stmt)
        if (typeMatch) {
          const [_, qualifiedName, isEnum] = typeMatch
          if (!isEnum) {
            const typeId = parseIdentifier(qualifiedName)
            const typeSchema = typeId.schema ? unquote(typeId.schema) : 'public'

            const typeExists = await client.scalar<boolean>(sql`
              SELECT EXISTS (
                SELECT 1
                FROM pg_type
                WHERE typname = ${sql.val(unquote(typeId.name))}
                  AND typnamespace = ${sql.val(typeSchema)}::regnamespace
              );
            `)

            if (typeExists && (await hasTypeChanged(client, stmt))) {
            } else {
              await client.query(sql.unsafe(stmt))
              stmt = ''
            }
          }
        }
      })

      stmts[i] = stmt
    }

    const newSql = sift(stmts).join('\n\n').trim()
    // console.log('=== %O ===', file)
    // console.log(newSql)

    try {
      fs.unlinkSync(outFile)
    } catch {}
    fs.writeFileSync(outFile, newSql)
  }

  let preApplyDDL = ''

  const changedTypes: SQLObject[] = []
  if (declaredTypes.length) {
    await client.query(sql`CREATE SCHEMA IF NOT EXISTS nano;`)
    await Promise.all(
      declaredTypes.map(async type => {
        if (await hasTypeChanged(client, type)) {
          log('type %s has changed', type.name)
          changedTypes.push(type)
        }
      }),
    )

    preApplyDDL += '\n\n' + declaredTypes.map(type => type.stmt).join('\n\n')
  }

  console.log('=== === === pre-plan.sql === === ===')
  console.log(prePlanDDL)
  console.log('=== === === pre-apply.sql === === ===')
  console.log(preApplyDDL)
  console.log('=== === === === === === === === === ===')

  const prePlanFile = path.join(env.untrackedDir, 'pre-plan.sql')
  fs.writeFileSync(prePlanFile, prePlanDDL)

  const preApplyFile = path.join(env.untrackedDir, 'pre-apply.sql')
  fs.writeFileSync(preApplyFile, preApplyDDL)

  await Promise.all([
    ...fixedFuncs.map(func => {
      return client.query(
        sql.unsafe(`DROP FUNCTION IF EXISTS ${func.name} (${func.signature});`),
      )
    }),
    ...changedTypes.map(type =>
      client.query(sql.unsafe(`DROP TYPE IF EXISTS ${type.name} CASCADE;`)),
    ),
  ])

  return async () => {
    for (const { stmt } of fixedFuncs) {
      await client.query(
        sql.unsafe(
          stmt.replace(
            /CREATE\s+FUNCTION\s+([^;]+?)\s+RETURNS\s+SETOF\s+/gi,
            (match, signature) => {
              return `DROP FUNCTION ${signature}; ${match}`
            },
          ),
        ),
      )
    }
  }
}

function md5Hash(input: string): string {
  return crypto.createHash('md5').update(input).digest('hex')
}

/**
 * Compare a type to the existing type in the database.
 *
 * @returns `true` if the type has changed, `false` otherwise.
 */
async function hasTypeChanged(client: Client, type: SQLObject) {
  const typeName = parseIdentifier(type.name)
  const typeStmt = typeName.schema
    ? type.stmt.replace(typeName.schema, 'nano')
    : type.stmt.replace(typeName.name, 'nano.' + typeName.name)

  // Add the current type to the database (but under the "nano" schema),
  // so we can compare it to the existing type.
  await client.query(
    sql`DROP TYPE IF EXISTS nano.${sql.unsafe(typeName.name)} CASCADE; ${sql.unsafe(typeStmt)}`,
  )

  const selectTypeByName = (name: string, schema: string) => sql`
    SELECT
      a.attname AS column_name,
      a.atttypid AS type_id,
      a.attnum AS column_number
    FROM
      pg_attribute a
    JOIN
      pg_type t ON t.oid = a.attrelid
    WHERE
      t.typname = ${sql.val(unquote(name))}
      AND t.typnamespace = ${sql.val(unquote(schema))}::regnamespace
    ORDER BY
      a.attnum
  `

  const hasChanges = await client.scalar<boolean>(
    sql`
      WITH type1 AS (
        ${selectTypeByName(typeName.name, typeName.schema ?? 'public')}
      ),
      type2 AS (
        ${selectTypeByName(typeName.name, 'nano')}
      )
      SELECT 
        EXISTS (
          SELECT 1
          FROM (
            SELECT * FROM type1
            EXCEPT
            SELECT * FROM type2
          ) diff1
        ) OR
        EXISTS (
          SELECT 1
          FROM (
            SELECT * FROM type2
            EXCEPT
            SELECT * FROM type1
          ) diff2
        ) AS has_changes;
    `,
  )

  // Clean up the temporary type.
  await client.query(
    sql`DROP TYPE IF EXISTS nano.${sql.unsafe(typeName.name)} CASCADE;`,
  )

  return hasChanges
}

// async function hasFunctionChanged(client: Client, func: SQLFile) {
//   const funcName = parseIdentifier(func.stmts)

//   const hasChanges = await client.scalar<boolean>(
//     sql`
//       WITH function1 AS (
//         SELECT
//           p.proname AS function_name,
//           p.proargtypes::oid[] AS argument_types,
//           p.prorettype AS return_type,
//           p.prosrc AS function_body,
//           p.probin AS internal_body,
//           p.provariadic AS variadic_type,
//           p.proisagg AS is_aggregate,
//           p.prokind AS function_kind
//         FROM
//           pg_proc p
//         JOIN
//           pg_namespace n ON p.pronamespace = n.oid
//         WHERE
//           p.proname = ${sql.val(typeName.identifier)}
//           AND n.nspname = ${sql.val(typeName.namespace ?? 'public')}
//       ),
//       function2 AS (
//         SELECT
//           p.proname AS function_name,
//           p.proargtypes::oid[] AS argument_types,
//           p.prorettype AS return_type,
//           p.prosrc AS function_body,
//           p.probin AS internal_body,
//           p.provariadic AS variadic_type,
//           p.proisagg AS is_aggregate,
//           p.prokind AS function_kind
//         FROM
//           pg_proc p
//         JOIN
//           pg_namespace n ON p.pronamespace = n.oid
//         WHERE
//           p.proname = 'my_function'
//           AND n.nspname = 'schema2'
//       )
//       SELECT
//         f1.function_name = f2.function_name AND
//         f1.argument_types = f2.argument_types AND
//         f1.return_type = f2.return_type AND
//         COALESCE(f1.function_body, '') = COALESCE(f2.function_body, '') AND
//         COALESCE(f1.internal_body, '') = COALESCE(f2.internal_body, '') AND
//         f1.variadic_type = f2.variadic_type AND
//         f1.is_aggregate = f2.is_aggregate AND
//         f1.function_kind = f2.function_kind AS functions_are_equal
//       FROM
//         function1 f1,
//         function2 f2;
//     `,
//   )

//   return hasChanges
// }

/**
 * Split a string of SQL statements into individual statements. This assumes
 * your SQL is properly indented.
 */
function splitStatements(stmts: string): string[] {
  const regex = /;\s*\n(?=\S)/g
  const statements = stmts.split(regex)
  return statements.map(stmt => stmt.trim() + ';')
}

/**
 * Replace a range of characters in a string with a replacement string.
 */
function replaceSubstring(
  input: string,
  [start, length]: [start: number, length: number],
  replacement: string,
): string {
  console.log('replaceSubstring', { input, start, length, replacement })
  return input.slice(0, start) + replacement + input.slice(start + length)
}

// Remove surrounding double quotes if present.
function unquote(str: string) {
  if (str.startsWith('"') && str.endsWith('"')) {
    return str.slice(1, -1)
  }
  return str
}

function compareIdentifiers(left: string, right: string) {
  const leftParts = parseIdentifier(left)
  const rightParts = parseIdentifier(right)

  console.log('compareIdentifiers', { leftParts, rightParts })

  const leftSchema = leftParts.schema ? unquote(leftParts.schema) : 'public'
  const rightSchema = rightParts.schema ? unquote(rightParts.schema) : 'public'

  return (
    leftSchema === rightSchema &&
    unquote(leftParts.name) === unquote(rightParts.name)
  )
}
